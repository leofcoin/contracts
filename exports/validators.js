const between=(min,max,length=1)=>{let arr=[];for(let i=0;i<length;++i)arr=[...arr,Math.floor(Math.random()*(max+1-min)+min)];return arr},lottery=(numbers=7,max=100,min=0,length=100)=>{let arr=[],ran=between(min,max,length);ran=(arr=>arr.filter((el,pos,arr)=>arr.indexOf(el)==pos))(ran);for(let i=0;i<numbers;++i){const _ran=between(min,ran.length-1,ran.length)[0];arr=[...arr,ran[_ran]]}return arr};class Meta{#creator;#createdAt=BigInt(Date.now());constructor(state){state?(this.#creator=state.creator,this.#createdAt=state.createdAt):(this.#creator=msg.sender,this.#createdAt=BigInt(Date.now()))}get state(){return{creator:this.#creator,createdAt:this.#createdAt}}get creator(){return this.#creator}get createdAt(){return this.#createdAt}}class Roles extends Meta{#roles={OWNER:[],MINT:[],BURN:[]};constructor(state){if(super(state),state?.roles){if(!(state.roles instanceof Object))throw new TypeError("expected roles to be an object");this.#roles={...state.roles}}else this.#grantRole(msg.sender,"OWNER")}get state(){return{...super.state,roles:this.roles}}get roles(){return{...this.#roles}}hasRole(address,role){return!!this.#roles[role]&&this.#roles[role].includes(address)}#grantRole(address,role){if(this.hasRole(address,role))throw new Error(`${role} role already granted for ${address}`);this.#roles[role].push(address)}#revokeRole(address,role){if(!this.hasRole(address,role))throw new Error(`${role} role already revoked for ${address}`);if("OWNER"===role&&1===this.#roles[role].length)throw new Error("atleast one owner is needed!");this.#roles[role].splice(this.#roles[role].indexOf(address))}grantRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#grantRole(address,role)}revokeRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#revokeRole(address,role)}}class Validators extends Roles{#name="LeofcoinValidators";#validators=[];#currentValidator;#currency;#minimumBalance=BigInt(5e4);#balances={};get state(){return{...super.state,balances:this.#balances,minimumBalance:this.#minimumBalance,currency:this.#currency,validators:this.#validators,currentValidator:this.#currentValidator}}constructor(tokenAddress,state){super(state),state?(this.#minimumBalance=BigInt(state.minimumBalance),this.#currency=state.currency,this.#validators=state.validators,this.#balances=state.balances,this.#currentValidator=state.currentValidator):(this.#currency=tokenAddress,this.#validators.push(msg.sender),this.#currentValidator=msg.sender)}get currentValidator(){return this.#currentValidator}get name(){return this.#name}get currency(){return this.#currency}get validators(){return this.#validators}get totalValidators(){return this.#validators.length}get minimumBalance(){return this.#minimumBalance}changeCurrency(currency){if(!this.hasRole(msg.sender,"OWNER"))throw new Error("not an owner");this.#currency=currency}has(validator){return this.#validators.includes(validator)}#isAllowed(address){if(msg.sender!==address&&!this.hasRole(msg.sender,"OWNER"))throw new Error("sender is not the validator or owner");return!0}async addValidator(validator){if(this.#isAllowed(validator),this.has(validator))throw new Error("validator already exists");const balance=await msg.staticCall(this.currency,"balanceOf",[validator]);if(this.minimumBalance>balance)throw new Error(`balance to low! got: ${balance} need: ${this.#minimumBalance}`);await msg.call(this.currency,"transfer",[validator,msg.contract,this.#minimumBalance]),this.#balances[validator]=this.#minimumBalance,this.#validators.push(validator)}async removeValidator(validator){if(this.#isAllowed(validator),!this.has(validator))throw new Error("validator not found");await msg.call(this.currency,"transfer",[msg.contract,validator,this.#minimumBalance]),delete this.#balances[validator],this.#validators.splice(this.#validators.indexOf(validator),1)}shuffleValidator(){const _peers=state.peers,peers=_peers.filter(peer=>this.#validators.includes(peer[0])).map(peer=>(peer[1].totalBytes=peer[1].bw.up+peer[1].bw.down,peer)).sort((a,b)=>b[1].totalBytes-a[1].totalBytes).splice(0,_peers.length>128?128:_peers.length);let nextValidator=peers[lottery(1,peers.length-1)[0]][0];if(this.#currentValidator===nextValidator&&1!==peers.length){nextValidator=peers[lottery(1,peers.length-1)[0]][0]}this.#currentValidator=nextValidator}}export{Validators as default};
