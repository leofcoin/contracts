class Meta{#creator;#createdAt=BigInt(Date.now());constructor(state){state?(this.#creator=state.creator,this.#createdAt=state.createdAt):(this.#creator=msg.sender,this.#createdAt=BigInt(Date.now()))}get state(){return{creator:this.#creator,createdAt:this.#createdAt}}get creator(){return this.#creator}get createdAt(){return this.#createdAt}}class Roles extends Meta{#roles={OWNER:[],MINT:[],BURN:[]};constructor(state){if(super(state),state?.roles){if(!(state.roles instanceof Object))throw new TypeError("expected roles to be an object");this.#roles={...state.roles}}else this.#grantRole(msg.sender,"OWNER")}get state(){return{...super.state,roles:this.roles}}get roles(){return{...this.#roles}}hasRole(address,role){return!!this.#roles[role]&&this.#roles[role].includes(address)}#grantRole(address,role){if(this.hasRole(address,role))throw new Error(`${role} role already granted for ${address}`);this.#roles[role].push(address)}#revokeRole(address,role){if(!this.hasRole(address,role))throw new Error(`${role} role already revoked for ${address}`);if("OWNER"===role&&1===this.#roles[role].length)throw new Error("atleast one owner is needed!");this.#roles[role].splice(this.#roles[role].indexOf(address))}grantRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#grantRole(address,role)}revokeRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#revokeRole(address,role)}}class Token extends Roles{#name;#symbol;#holders=0n;#balances={};#approvals={};#decimals=18;#totalSupply=0n;constructor(name,symbol,decimals=18,state){if(!name)throw new Error("name undefined");if(!symbol)throw new Error("symbol undefined");super(state),state?(this.#balances=(balances=>{const _balances={};for(const address in balances)_balances[address]=BigInt(balances[address]);return _balances})(state.balances),this.#approvals=(approvals=>{const _approvals={};for(const owner in approvals){_approvals[owner]={};for(const operator in approvals[owner])_approvals[owner][operator]=BigInt(approvals[owner][operator])}return _approvals})(state.approvals),this.#holders=BigInt(state.holders),this.#totalSupply=BigInt(state.totalSupply)):(this.#name=name,this.#symbol=symbol,this.#decimals=decimals)}get state(){return{...super.state,holders:this.holders,balances:this.balances,approvals:{...this.#approvals},totalSupply:this.totalSupply}}get totalSupply(){return this.#totalSupply}get name(){return this.#name}get symbol(){return this.#symbol}get holders(){return this.#holders}get balances(){return{...this.#balances}}get approvals(){return this.#approvals}get decimals(){return this.#decimals}mint(to,amount){if(!this.hasRole(msg.sender,"MINT"))throw new Error("not allowed");this.#totalSupply=this.#totalSupply+amount,this.#increaseBalance(to,amount)}burn(from,amount){if(!this.hasRole(msg.sender,"BURN"))throw new Error("not allowed");this.#totalSupply=this.#totalSupply-amount,this.#beforeTransfer(from,from,amount),this.#decreaseBalance(from,amount)}#beforeTransfer(from,to,amount){if(!from)throw new Error("address undefined");if(amount<0n)throw new Error("amount must be positive");if(!this.#balances[from]||this.#balances[from]<amount)throw new Error("amount exceeds balance")}#updateHolders(address,previousBalance){0n===this.#balances[address]?this.#holders-=1n:0n!==this.#balances[address]&&0n===previousBalance&&(this.#holders+=1n)}#increaseBalance(address,amount){this.#balances[address]||(this.#balances[address]=0n);const previousBalance=this.#balances[address];this.#balances[address]=this.#balances[address]+amount,this.#updateHolders(address,previousBalance)}#decreaseBalance(address,amount){const previousBalance=this.#balances[address];this.#balances[address]=this.#balances[address]-amount,this.#updateHolders(address,previousBalance)}balance(){return this.#balances[msg.sender]}balanceOf(address){return this.#balances[address]}setApproval(operator,amount){const owner=msg.sender;this.#approvals[owner]||(this.#approvals[owner]={}),this.#approvals[owner][operator]=BigInt(amount)}approved(owner,operator,amount){return this.#approvals[owner][operator]===amount}transfer(from,to,amount){amount=BigInt(amount),this.#beforeTransfer(from,to,amount),this.#decreaseBalance(from,amount),this.#increaseBalance(to,amount)}}class Power extends Token{constructor(state){super("Power","PWR",18,state)}}export{Power as default};
