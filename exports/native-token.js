class ContractCreator{#creator;constructor(state){this.#creator=state?state.contractCreator:msg.sender}get _contractCreator(){return this.#creator}get state(){return{contractCreator:this.#creator}}get _isContractCreator(){return msg.sender===this.#creator}}class Roles extends ContractCreator{#roles={OWNER:[],MINT:[],BURN:[]};constructor(state){if(super(state),state?.roles){if(!(state.roles instanceof Object))throw new TypeError("expected roles to be an object");this.#roles={...state.roles,...this.#roles}}else this.#grantRole(msg.sender,"OWNER")}get state(){return{...super.state,roles:this.roles}}get roles(){return{...this.#roles}}hasRole(address,role){return!!this.#roles[role]&&this.#roles[role].includes(address)}#grantRole(address,role){if(this.hasRole(address,role))throw new Error(`${role} role already granted for ${address}`);this.#roles[role].push(address)}#revokeRole(address,role){if(!this.hasRole(address,role))throw new Error(`${role} role already revoked for ${address}`);if("OWNER"===role&&1===this.#roles[role].length)throw new Error("atleast one owner is needed!");this.#roles[role].splice(this.#roles[role].indexOf(address))}grantRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#grantRole(address,role)}revokeRole(address,role){if(!this.hasRole(address,"OWNER"))throw new Error("Not allowed");this.#revokeRole(address,role)}}class Token extends Roles{#name;#symbol;#holders=BigInt(0);#balances={};#approvals={};#decimals=18;#totalSupply=BigInt(0);#maxSupply=BigInt(0);#stakingContract;constructor(name,symbol,decimals=18,state){if(!name)throw new Error("name undefined");if(!symbol)throw new Error("symbol undefined");super(state),state?(this.#balances=(balances=>{const _balances={};for(const address in balances)_balances[address]=BigInt(balances[address]);return _balances})(state.balances),this.#approvals=(approvals=>{const _approvals={};for(const owner in approvals){_approvals[owner]={};for(const operator in approvals[owner])_approvals[owner][operator]=BigInt(approvals[owner][operator])}return _approvals})(state.approvals),this.#holders=BigInt(state.holders),this.#totalSupply=BigInt(state.totalSupply),this.#name=name,this.#symbol=symbol,this.#decimals=decimals,this.#maxSupply=BigInt(state.maxSupply)):(this.#name=name,this.#symbol=symbol,this.#decimals=decimals)}get state(){return{...super.state,name:this.#name,symbol:this.#symbol,decimals:this.#decimals,holders:this.holders,balances:this.balances,approvals:{...this.#approvals},totalSupply:this.totalSupply,maxSupply:this.#maxSupply}}get maxSupply(){return this.#maxSupply}get totalSupply(){return this.#totalSupply}get name(){return this.#name}get symbol(){return this.#symbol}get holders(){return this.#holders}get balances(){return{...this.#balances}}get approvals(){return this.#approvals}get decimals(){return this.#decimals}mint(to,amount){if(!this.hasRole(msg.sender,"MINT"))throw new Error("mint role required");const supply=this.#totalSupply+amount;if(0n===this.#maxSupply)this.#totalSupply=supply,this.#increaseBalance(to,amount);else{if(!(supply<=this.#maxSupply))throw new Error("amount exceeds max supply");this.#totalSupply=supply,this.#increaseBalance(to,amount)}}burn(from,amount){if(!this.hasRole(msg.sender,"BURN")&&msg.sender!==from)throw new Error("not the owner or burn role required");if(this.#balances[from]<amount)throw new Error("amount exceeds balance");const total=this.#totalSupply-amount;if(!(total>=0))throw new Error("amount exceeds total supply");this.#totalSupply=total,this.#decreaseBalance(from,amount)}#beforeTransfer(from,to,amount){if(!this.#balances[from]||this.#balances[from]<amount)throw new Error("amount exceeds balance")}#updateHolders(address,previousBalance){0n===this.#balances[address]?this.#holders-=1n:0n!==this.#balances[address]&&0n===previousBalance&&(this.#holders+=1n)}#increaseBalance(address,amount){this.#balances[address]||(this.#balances[address]=BigInt(0));const previousBalance=this.#balances[address];this.#balances[address]=this.#balances[address]+=amount,this.#updateHolders(address,previousBalance)}#decreaseBalance(address,amount){const previousBalance=this.#balances[address];this.#balances[address]=this.#balances[address]-=amount,this.#updateHolders(address,previousBalance)}balance(){return this.#balances[msg.sender]}balanceOf(address){return this.#balances[address]}setApproval(operator,amount){const owner=msg.sender;this.#approvals[owner]||(this.#approvals[owner]={}),this.#approvals[owner][operator]=BigInt(amount)}approved(owner,operator,amount){return this.#approvals[owner][operator]===amount}transfer(from,to,amount){amount=BigInt(amount),this.#beforeTransfer(from,to,amount),this.#decreaseBalance(from,amount),this.#increaseBalance(to,amount)}}class Leofcoin extends Token{constructor(state){super("Leofcoin","LFC",18,state)}}export{Leofcoin as default};
